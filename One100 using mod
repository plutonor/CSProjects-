/**
 * One100.java
 * @version 09/09/14
 * @author Thomas Noble
*/
import java.util.*;
public class One100 {
   public static final int MAX/*1 to 2147483647*/= 100;
   public static void main(String[] args) {
      int[] num = {1, 0};
      while (num[0] != 0) {
      //makes the code run until you quit
         num = askNum();
         //num = 0 if response was "quit" or "Quit"
         if (num[0] != 0) {
            ArrayList<Integer> factors = getFactors(num);
            toText(factors);
         }
      }
   }
   
   public static int[] askNum() {
	   //gives error message if more than 1 number
   //asks and stores a number between 1 and MAX
      Scanner console = new Scanner(System.in);
      int[] num = {0, 0};
      boolean good = true;
      //good is used to check that the input is a number between 1 and MAX or quit
      boolean quit = false;
      //quit is to tell if the input was quit
      int spaces = 0;
      boolean pNums = false;
      int marker = 0;
      System.out.println("Please input an integer(s) from 1 to " + MAX + ".");
      String text = console.nextLine();
      if (text.equals("quit") || text.equals("Quit")) {
      //checks if the input was quit
         quit = true;
      } else {
      //if the input wasn't quit, it figures out the number
         for (int i = 0; i < text.length(); i++) {
            if ((text.charAt(i) - 48 > 9 || text.charAt(i) - 48 < 0) && text.charAt(i) != ' ') {
            //checks if the character is a number
               good = false;
               //if the character isn't a number, the input isn't "good"
            } else if (text.charAt(i) == ' ') {
            	spaces++;
            	pNums = true;
            	marker = i;
            } else if (spaces <= 1){
               num[spaces] += ((text.charAt(i) - 48) * ((int) Math.pow(10, text.length() - 1 - i)));
               //This adds the number in the correct decimal place
               //doesn't if there are multiple numbers
               //((int) Math.pow(10, text.length() - 1 - i)) is too big for the first number of 2
            }
         }
      }
      if (pNums) {
    	  num[0] /= (int) Math.pow(10, text.length() - marker);
      }
      boolean okay2 = true;
      if (pNums) {
    	  if (num[1] < 1 || num[1] > MAX) {
    		  okay2 = false;
    	  }
      }
      boolean okay1 = true;
	  if (num[0] < 1 || num[0] > MAX) {
		  okay1 = false;
	  }
	  if (spaces > 1) {
		  good = false;
	  }
      if ((!good || !okay1 || !okay2) && !quit) {
      //gives an error message for a bad entry and asks again
         System.out.println("ERROR! invalid entry");
         num = askNum();
      }
      if (quit) {
      //sets the number as 0 if the user wants to quit
         num[0] = 0;
      }
      return num;
   }
   
   public static ArrayList<Integer> getFactors(int[] num) {
      ArrayList<Integer> factors1 = new ArrayList<Integer>();
      ArrayList<Integer> reverse1 = new ArrayList<Integer>();
      ArrayList<Integer> factors2 = new ArrayList<Integer>();
      ArrayList<Integer> reverse2 = new ArrayList<Integer>();
      for (int pFact = 1; pFact <= Math.sqrt(num[0]); pFact++) {
      //checks all ints between 1 and sqrt of the number for factors
      //pFact = possible Factor
         if (num[0] % pFact == 0) {
         //checks that pFact is a factor
            factors1.add(pFact);
            if (num[0] / pFact != pFact) {
            //adds the complementary factor to reverse if pFact ISN'T the sqrt
               reverse1.add(num[0] / pFact);
            }
         }
      }
      for (int pFact = 1; pFact <= Math.sqrt(num[1]); pFact++) {
      //checks all ints between 1 and sqrt of the number for factors
      //pFact = possible Factor
         if (num[1] % pFact == 0) {
         //checks that pFact is a factor
            factors2.add(pFact);
            if (num[1] / pFact != pFact) {
            //adds the complementary factor to reverse if pFact ISN'T the sqrt
               reverse2.add(num[1] / pFact);
            }
         }
      }
      for (int opFact = reverse1.size() - 1; opFact >= 0; opFact--) {
      //reverses reverse and adds the factors to factors
         factors1.add(reverse1.get(opFact));
      }
      for (int opFact = reverse2.size() - 1; opFact >= 0; opFact--) {
      //reverses reverse and adds the factors to factors
         factors2.add(reverse2.get(opFact));
      }
      factors1.add(num[0]);
      factors2.add(num[1]);
      int gCF = 0;
      //for some reason, reverse doesn't include the original number
      if (num[1] > 0) {
    	  for (int num1 = 0; num1 < factors1.size() - 1; num1++) {
        	  for (int num2 = 0; num2 < factors2.size() - 1; num2++) {
        		  if((int) factors1.get(num1) == (int) factors2.get(num2)) {
        			  gCF = (int) factors1.get(num1);
        		  }
        	  }
    	  }
      }
      if (gCF > 0) {
    	  factors1.clear();
    	  factors1.add(gCF);
      }
      return factors1;
   }
   
   public static void toText(ArrayList<Integer> factors) {
      System.out.print("factors: ");
      System.out.print("" + factors.get(0));
      //end post
      for (int current = 1; current < factors.size() - 1; current++) {
      //simple to text for loop
         System.out.print(", " + factors.get(current));
      }
      System.out.println();
      //prepares for next input
   }
}
